<template>
    <div>
        <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%" :id="tableid">
            <thead>
                <tr>
                    <th class="sub-cell" @click="sortBy('Sub')">Sub</th>
                    <th class="prof-cell" @click="sortBy('Prof')"></th>
                    <th class="text-left" @click="sortBy('Name')">Name</th>
                    <th class="stat-cell" v-for="(modifier, index) in modifiers" @click="sortBy('Modifier', index)":data-original-title="modifier.name + '<br>' + modifier.tooltip">
                        <img :src="modifier.icon" :alt="modifier.name" class="icon icon-hover">
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr v-for="row in sortData((mode ? tableDataTarget.rows : tableData.rows))"
                    :class="{active: row.player.id === playerindex}">
                    <td>{{row.player.group}}</td>
                    <td :data-original-title="row.player.profession">
                        <img :src="row.player.icon" :alt="row.player.profession" class="icon"><span
                            style="display:none">{{row.player.profession}}</span>
                    </td>
                    <td class="text-left">{{row.player.name}}</td>
                    <td v-for="(modifier, index) in modifiers" :class="{approximate: modifier.approximate}"
                        :data-original-title="getTooltip(row.data[index], modifier)">
                        {{getCellValue(row.data[index], modifier)}}
                    </td>
                </tr>
            </tbody>
            <tfoot v-if="sum">
                <tr v-for="row in (mode ? tableDataTarget.sums : tableData.sums)">
                    <td></td>
                    <td></td>
                    <td class="text-left">{{row.name}}</td>
                    <td v-for="(modifier, index) in modifiers" :class="{approximate: modifier.approximate}"
                        :data-original-title="getTooltip(row.data[index], modifier)">
                        {{getCellValue(row.data[index], modifier)}}
                    </td>
                </tr>
            </tfoot>
        </table>
    </div>
</template>

<script>
    Vue.component("dmgmodifier-table-component", {
        props: ['phaseindex', 'id', 'playerindex', 'playerindices', 'activetargets', 'modifiers', 'modifiersdata', 'mode', 'sum'],
        mixins: [numberComponent],
        template: `${template}`,
        data: function () {
            return {
                cache: new Map(),
                cacheTarget: new Map(),
                sortdata: {
                    order: "asc",
                    index: 0,
                    key: "Prof"
                }
            };
        },
        computed: {
            tableid: function() {
                return this.id;
            },
            phase: function () {
                return logData.phases[this.phaseindex];
            },
            indicesToUse: function () {
                let res = [];
                if (this.playerindices !== null) {
                    for (let i = 0; i < this.playerindices.length; i++) {
                        res.push(this.playerindices[i]);
                    }
                    return res;
                }
                for (let i = 0; i < logData.players.length; i++) {
                    res.push(i);
                }
                return res;
            },
            tableData: function () {
                if (this.cache.has(this.phaseindex)) {
                    return this.cache.get(this.phaseindex);
                }
                let rows = [];
                let sums = [];
                let groups = [];
                let total = {
                    name: "Total",
                    data: []
                };
                let j;
                for (let i = 0; i < this.indicesToUse.length; i++) {
                    let index = this.indicesToUse[i];
                    let player = logData.players[index];
                    if (player.isFake) {
                        continue;
                    }
                    if (!player.notInSquad && !groups[player.group]) {
                        groups[player.group] = {
                            name: "Group" + player.group,
                            data: []
                        };
                    }
                    let dmgModifier = this.modifiersdata[index].data;
                    let data = [];
                    for (j = 0; j < this.modifiers.length; j++) {
                        data[j] = dmgModifier[j];
                        if (!player.notInSquad) {
                            if (!groups[player.group].data[j]) {
                                groups[player.group].data[j] = [0, 0, 0, 0];
                            }
                            if (!total.data[j]) {
                                total.data[j] = [0, 0, 0, 0];
                            }
                            for (let k = 0; k < data[j].length; k++) {
                                groups[player.group].data[j][k] += data[j][k];
                                total.data[j][k] += data[j][k];
                            }
                        }
                        
                    }
                    rows.push({
                        player: player,
                        data: data
                    });
                }
                for (let i = 0; i < groups.length; i++) {
                    if (groups[i]) {
                        sums.push(groups[i]);
                    }
                }
                sums.push(total);
                let res = {
                    rows: rows,
                    sums: sums
                };
                this.cache.set(this.phaseindex, res);
                return res;
            },
            tableDataTarget: function () {
                let cacheID = this.phaseindex + '-';
                cacheID += getTargetCacheID(this.activetargets);
                if (this.cacheTarget.has(cacheID)) {
                    return this.cacheTarget.get(cacheID);
                }
                let rows = [];
                let sums = [];
                let groups = [];
                let total = {
                    name: "Total",
                    data: []
                };
                let j;
                for (let i = 0; i < this.indicesToUse.length; i++) {
                    let index = this.indicesToUse[i];
                    let player = logData.players[index];
                    if (player.isFake) {
                        continue;
                    }
                    if (!player.notInSquad && !groups[player.group]) {
                        groups[player.group] = {
                            name: "Group" + player.group,
                            data: []
                        };
                    }
                    let data = [];
                    for (j = 0; j < this.modifiers.length; j++) {
                        data[j] = [0, 0, 0, 0];
                        if (!player.notInSquad) {
                            if (!groups[player.group].data[j]) {
                                groups[player.group].data[j] = [0, 0, 0, 0];
                            }
                            if (!total.data[j]) {
                                total.data[j] = [0, 0, 0, 0];
                            }
                        }
                    }
                    let dmgModifier = this.modifiersdata[index].dataTarget;
                    for (j = 0; j < this.activetargets.length; j++) {
                        let modifier = dmgModifier[this.activetargets[j]];
                        for (let k = 0; k < this.modifiers.length; k++) {
                            let targetData = modifier[k];
                            let curData = data[k];
                            for (let l = 0; l < targetData.length; l++) {
                                curData[l] += targetData[l];
                            }
                        }
                    }
                    if (!player.notInSquad) {
                        for (j = 0; j < this.modifiers.length; j++) {
                            for (let k = 0; k < data[j].length; k++) {
                                groups[player.group].data[j][k] += data[j][k];
                                total.data[j][k] += data[j][k];
                            }
                        }
                    }

                    rows.push({
                        player: player,
                        data: data
                    });
                }
                for (let i = 0; i < groups.length; i++) {
                    if (groups[i]) {
                        sums.push(groups[i]);
                    }
                }
                sums.push(total);
                let res = {
                    rows: rows,
                    sums: sums
                };
                this.cacheTarget.set(cacheID, res);
                return res;
            }
        },
        methods: {
            sortBy: function(key, index) {
                let oldKey = this.sortdata.key;
                this.sortdata.key = key;
                if (oldKey !== key) {
                    this.sortdata.order = "asc";
                } else {
                    this.sortdata.order = this.sortdata.order === "asc" ? "desc" : "asc";
                }
                this.sortdata.index = index || 0;
            },
            sortData: function(rows) {
                let order = this.sortdata.order === "asc" ? 1 : -1;
                switch (this.sortdata.key) {
                    case "Sub":
                        rows.sort((x,y) => order * (x.player.group - y.player.group));
                        break;
                    case "Prof":
                        rows.sort((x,y) => order * x.player.profession.localeCompare(y.player.profession));
                        break;
                    case "Name":
                        rows.sort((x,y) => order * x.player.name.localeCompare(y.player.name));
                        break;
                    case "Modifier":
                        let index = this.sortdata.index;
                        let modifier = this.modifiers[index];
                        rows.sort((x,y) => order * this.getCellValue(x.data[index], modifier).localeCompare(this.getCellValue(y.data[index], modifier)));
                        break;
                }
                return rows;
            },
            getTooltip: function (item, mod) {
                if (item[0] === 0) {
                    return null;
                }
                let hits = item[0] + " out of " + item[1] + " hits";
                let percent;
                if (mod.skillBased) {
                    percent = this.round3(1000.0 * item[1] / this.phase.duration) + " hits/s";
                } else {
                    percent = this.round3(100.0 * item[0] / item[1]) + " hit %";
                }
                let res = hits + "<br>" + percent;
                if (item[2] === 0) {
                    return res;
                }
                let gain;
                if (mod.nonMultiplier) {
                    gain = "Damage Done: ";
                } else {
                    gain = "Pure Damage: ";
                }
                gain += this.round(item[2]);
                if (mod.nonMultiplier) {
                    gain += "<br>Total Damage: " + this.round3(100.0 * item[2] / item[3]) + "%";
                }
                return res + "<br>" + gain;
            },
            getCellValue: function (item, mod) {
                if (item[2] === 0) {
                    if (item[0] > 0) {
                        return 'Tooltip';
                    }
                    return '-';
                }
                if (mod.nonMultiplier) {
                    return 'Tooltip';
                }
                let damageIncrease = this.round3(100 * (item[3] / (item[3] - item[2]) - 1.0));
                if (Math.abs(damageIncrease) < 1e-6 || isNaN(damageIncrease)) {
                    return "-";
                }
                return damageIncrease + '%';
            }
        },
        mounted() {
            //refreshTable(this.tableid, this.sortdata);
        },
        updated() {
            //refreshTable(this.tableid, this.sortdata);
        },
        activated() {
            //refreshTable(this.tableid, this.sortdata);
        },
    });
</script>